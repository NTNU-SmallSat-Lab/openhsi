# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/07_sensors.ipynb (unless otherwise specified).

__all__ = ['read_packet', 'decode_packet', 'fields_dict', 'SensorStream']

# Cell

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from datetime import datetime
import os
from fastcore.meta import delegates

import param
import panel as pn
pn.extension()

import holoviews as hv
hv.extension('bokeh',logo=False)


# Cell

import time
import serial
import numpy as np
import pandas as pd

from pathlib import Path
#import Jetson.GPIO as GPIO
import datetime
import pickle

# Cell
#hardware

#import GPIO

# Cell
#hardware

def read_packet(header:chr = "*", num_bytes:int = 80, timeout:float = 6.) -> "byte string":
    """Reads `num_bytes` of a data packet starting with `header` and timing out after `timeout` seconds if packet is invalid."""
    buff = b""

    # Check for packet start of frame
    start_time = time.time()
    while True:
        if ser.in_waiting> 0:
            b = ser.read()
            if b ==  b'*':
                #print("Received Packet")
                break

        if time.time() > start_time + timeout:
            print("No data packets.")
            return None

    # read the rest of data packet
    start_time = time.time()
    for i in range(num_bytes):
        if time.time() > start_time + timeout:
            print("Received Incomplete Packet")
            break

        if ser.in_waiting > 0:
            buff += ser.read()

    return buff



def decode_packet(buff:"byte string"=None) -> list:
    """Decode `buff` into a list of decoded variables"""
    if buff is None:
        return []

    contents = []
    np_buff = np.frombuffer(buff,dtype='uint8').astype(np.uint8)

    # sensor status
    contents.append( np_buff[0].view(np.uint8) ) # '*' is 42 decimal ASCII
    contents.append( np_buff[1].view(np.uint8) ) # imu status
    contents.append( np_buff[2].view(np.uint8) ) # air status
    contents.append( np_buff[3].view(np.uint8) ) # gps status

    # Real Time Clock
    contents.append( np_buff[4:6].view(np.uint16)  ) # rtc year
    contents.append( np_buff[6].view(np.uint8)     ) # rtc month
    contents.append( np_buff[7].view(np.uint8)     ) # rtc day
    contents.append( np_buff[8].view(np.uint8)     ) # rtc hour
    contents.append( np_buff[9].view(np.uint8)     ) # rtc minute
    contents.append( np_buff[10].view(np.uint8)    ) # rtc second
    contents.append( np_buff[11:13].view(np.uint16)) # rtc ms

    # Humidity, Pressure sensor
    contents.append( np_buff[13:15].view(np.uint16)  ) # humidity timestamp offset [ms]
    contents.append( np_buff[15:19].view(np.float32) ) # temperature [deg C]
    contents.append( np_buff[19:23].view(np.float32) ) # pressure [hPa]
    contents.append( np_buff[23:27].view(np.float32) ) # humidity [relative humidity %]

    # Inertial Measurement Unit
    contents.append( np_buff[27:29].view(np.uint16)  ) # imu timestamp offset [ms]
    contents.append( np_buff[29].view(np.uint8)      ) # calibration status
    contents.append( np_buff[30:34].view(np.float32) ) # quaternion w
    contents.append( np_buff[34:38].view(np.float32) ) # quaternion x
    contents.append( np_buff[38:42].view(np.float32) ) # quaternion y
    contents.append( np_buff[42:46].view(np.float32) ) # quaternion z

    # Global Positioning System
    contents.append( np_buff[46:48].view(np.uint16)  ) # gps timestamp offset [ms]
    contents.append( np_buff[48:52].view(np.int32)   ) # latitude [deg *10^-7]
    contents.append( np_buff[52:56].view(np.int32)   ) # longitude [deg *10^-7]
    contents.append( np_buff[56:60].view(np.int32)   ) # altitude [mm above ellipsoid]
    contents.append( np_buff[60].view(np.uint8)      ) # number of satellites in view and used in compute
    contents.append( np_buff[61:63].view(np.uint16)  ) # position DOP [*0.01]

    return contents



# Cell

# Define dictionary column name and data type
fields_dict = {'rtc_now': 'datetime',
             'rtc_temp': 'float',
             'air_temp': 'float',
             'air_pressure': 'float',
             'air_humidity': 'float',
             'imu_cal': 'int',
             'imu_temp': 'float',
             'euler_x': 'float',
             'euler_y': 'float',
             'euler_z': 'float',

             'quat0': 'float',
             'quat1': 'float',
             'quat2': 'float',
             'quat3': 'float',

             'mag_x': 'float',
             'mag_y': 'float',
             'mag_z': 'float',
             'gps_now': 'datetime',
             'latitude': 'float',
             'longitude': 'float',
             'altitude': 'float',
             'numSV': 'int',
             'velN': 'float',
             'velE': 'float',
             'gSpeed': 'float',
             'heading': 'float',
             'velAcc': 'float',
             'pDOP': 'float',
             'hAcc': 'float',
             'vAcc': 'float',
             'headAcc': 'float',
             'magDec': 'float',
             'magAcc': 'float'}

# Cell

class SensorStream():

    def __init__(self, baudrate=921_600, port="/dev/ttyTHS0", start_pin=27, save_dir="/xavier_ssd/data/"):

        self.ser = serial.Serial(port=port,
                                baudrate=baudrate,
                                bytesize=serial.EIGHTBITS,
                                parity=serial.PARITY_NONE,
                                stopbits=serial.STOPBITS_ONE,
                                )

        # Initialise serial port and wait
        self.ser.flushInput()

        # Instantiate for storing data
        self.data = []
        self.data_df = None

        self.start_pin = start_pin

        #GPIO.setwarnings(False)
        GPIO.setmode(GPIO.BCM) # BCM pin-numbering scheme from Raspberry Pi
        GPIO.setup(start_pin, GPIO.IN)
        self.dir = Path(f"{save_dir}{datetime.date.today()}")
        self.dir.mkdir(parents=False, exist_ok=True)
        self.fname = (f"{self.dir}/{datetime.datetime.now()}.pkl")

    def save(self):
        self.fname = (f"{self.dir}/{datetime.datetime.now()}.pkl")
        self.to_df(fields_dict,dropna_subset = ['rtc_now'],save_file=self.fname)
        print(f"Saved {len(self.data)} lines to {self.fname}")
        self.data = []
        print(self.data_df) #print(self.data_df.head(1)); print(self.data_df.tail(1))
        #self.ser.flushInput()


    def run(self):
        print("starting sensor datapacket reads")
        while True:
            try:
                if GPIO.input(self.start_pin) == True:
                    if len(self.data) == 0:
                        print("packets are coming")
                    self.record()

                    if len(self.data) > 2**14: # about 14k
                        self.save()

                else:
                    if len(self.data) > 0:
                        self.save()

                time.sleep(1)

            except KeyboardInterrupt:
                GPIO.cleanup()
                print("Exiting sensor read.")
                break
            except Exception as e:
                print(e)
                print("Attempting to start again!")
                self.ser.flushInput()
                self.data = []



    def record(self,max_timeout=2):

        start_time = time.time()

        # Check if line is ready
        while self.ser.inWaiting() > 0:

            # Read line from serial
            line_data = self.ser.readline()

            # Format data
            line_data = str(line_data).replace("b", "").replace("'", "").split(",")[:-1]

            # Append line to list
            self.data.append(line_data)

            if time.time()-start_time > max_timeout:
                print("timeout")
                self.ser.flushInput()
                break


    def to_df(self, fields_dict, dropna_subset = None, save_file = None):

        # Convert to dataframe and drop the first row of unclean data
        self.data_df = pd.DataFrame(self.data[1:], columns = fields_dict.keys())
        if dropna_subset:
            self.data_df.dropna(subset = dropna_subset, inplace=True)

        # Iterate through each column and update data type
        for field_name in fields_dict.keys():

            # Convert to float
            if fields_dict[field_name] == 'float' or fields_dict[field_name] == 'int':
                self.data_df[field_name] =  pd.to_numeric(self.data_df[field_name], errors='coerce')

            # Convert to datetime
            elif fields_dict[field_name] == 'datetime':
                self.data_df[field_name] =  pd.to_datetime(self.data_df[field_name], errors='coerce')

        if save_file is not None:
            with open(save_file,"wb") as handle:
                pickle.dump(self.data_df,handle,protocol=pickle.HIGHEST_PROTOCOL)

        # Return formatted data as dataframe
        return self.data_df