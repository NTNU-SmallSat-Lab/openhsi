---

title: Installing OpenHSI on Linux


keywords: fastai
sidebar: home_sidebar

summary: "A tutorial on installing the `openhsi` library and camera SDKs on Ubuntu and Rasberry Pi OS machines."
description: "A tutorial on installing the `openhsi` library and camera SDKs on Ubuntu and Rasberry Pi OS machines."
nb_path: "nbs/12_tutorial_installing_linux.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/12_tutorial_installing_linux.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>{% include warning.html content='This tutorial is a work in progress.' %}</p>
<h2 id="Requirements">Requirements<a class="anchor-link" href="#Requirements"> </a></h2><ul>
<li>Raspberry Pi Running Raspberry Pi OS (Raspbian) or Ubuntu 18.04 (using full 64 bit versions).<ul>
<li>A Raspberry Pi 4 with 8 GB RAM is recommended.</li>
</ul>
</li>
<li>Jetson development boards (E.g. Xavier) will also work. Some additional packages may be needed.</li>
<li>Debian based system<ul>
<li>recommended using Ubuntu 18.04 and 20.04</li>
</ul>
</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>{% include important.html content='Using <code>openhsi</code> requires generating large datacubes which take up lots of RAM. It is recommended to get a Raspberry Pi 4 with as much RAM as possible, especially if you want to capture raw data. Otherwise, you will need to a <code>processing_lvl</code> that includes binning to reduce the datacube size. ' %}
A Raspberry Pi does not have the same processing power as a typical laptop/computer and so expect the framerate to drop slightly. You want a lightweight operating system so the camera can run as fast as possible. If you have 8 GB of RAM, definitely get the Raspbian 64 bit OS so you can use &gt; 3 GB per process. Another benefit of running on ARM64 bit is that there are prebuilt OpenCV Python wheels - if your project requires <code>opencv-python</code>, then 64 bit is needed. 
{% include note.html content='The latest 64 bit Rasberry Pi OS (formerly Raspbian) is based on Debian 11 Bullseye (equivalent to Ubuntu 21+) and so some packages may not be updated to this platform yet. Also <code>systemd</code> is used to run scripts on startup.' %}{% include note.html content='Tutorial assumes you have a working OS on your system.' %}{% include tip.html content='Hyperspectral datacubes are really large so best to save them to an external SSD.' %}</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="1.-Python-Environment">1. Python Environment<a class="anchor-link" href="#1.-Python-Environment"> </a></h2><h4 id="Installing-Pyenv">Installing Pyenv<a class="anchor-link" href="#Installing-Pyenv"> </a></h4><p>The system python (on raspi in particular) is not always the most user friendly if any packages are not available pre-compiled, so using an alternative environment is recommended.
A good way to get a independent python environment is using <code>pyenv</code>. Of course any modern python install (py&gt;3.7) should work.</p>
<p>To install pyenv you can use the following commands:</p>
<div class="highlight"><pre><span></span>sudo apt-get update<span class="p">;</span> sudo apt-get install make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncursesw5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-dev

curl https://pyenv.run <span class="p">|</span> bash

<span class="nb">echo</span> <span class="s1">&#39;export PATH=&quot;$HOME/.pyenv/bin:$PATH&quot;&#39;</span> &gt;&gt; ~/.bashrc
<span class="nb">echo</span> <span class="s1">&#39;eval &quot;$(pyenv init -)&quot;&#39;</span> &gt;&gt; ~/.bashrc
<span class="nb">echo</span> <span class="s1">&#39;eval &quot;$(pyenv virtualenv-init -)&quot;&#39;</span> &gt;&gt; ~/.bashrc
<span class="nb">echo</span> <span class="s2">&quot;export PYENV_VIRTUALENV_DISABLE_PROMPT=1&quot;</span> &gt;&gt;~/.bashrc

<span class="nb">source</span> ~/.bashrc
</pre></div>
<p>With pyenv ready, you can easily install essentially any version of Python, from a vanilla cpython too miniforge too pypy.
For OpenHSI, Miniforge is a good option as the base environment for minimal effort. You can also get it without pyenv if you prefer at <a href="https://github.com/conda-forge/miniforge">https://github.com/conda-forge/miniforge</a>.
{% include note.html content='<a href="https://pythonspeed.com/articles/conda-vs-pip/">https://pythonspeed.com/articles/conda-vs-pip/</a> - some notes on conda vs pip.' %}</p>
<h4 id="Install-NodeJS">Install NodeJS<a class="anchor-link" href="#Install-NodeJS"> </a></h4><p>The Bokeh plotting library depends on nodeJS and is used to run OpenHSI interactive tools in a web browser.</p>
<div class="highlight"><pre><span></span>sudo apt install nodejs
</pre></div>
<h3 id="Miniforge-with-pyenv">Miniforge with pyenv<a class="anchor-link" href="#Miniforge-with-pyenv"> </a></h3><div class="highlight"><pre><span></span>pyenv install miniforge3
</pre></div>
<p>And then use conda later.</p>
<h4 id="Miniforge---Manual">Miniforge - Manual<a class="anchor-link" href="#Miniforge---Manual"> </a></h4><p>Miniforge3 is great lightweight option to get a new python environment up and running that will not interfere with the system one. You can download this from here <a href="https://github.com/conda-forge/miniforge#download">https://github.com/conda-forge/miniforge#download</a> and then install follow instructions.</p>
<div class="highlight"><pre><span></span>wget <span class="s2">&quot;https://github.com/conda-forge/miniforge/releases/latest/download/Miniforge3-</span><span class="k">$(</span>uname<span class="k">)</span><span class="s2">-</span><span class="k">$(</span>uname -m<span class="k">)</span><span class="s2">.sh&quot;</span>
bash Miniforge3-<span class="k">$(</span>uname<span class="k">)</span>-<span class="k">$(</span>uname -m<span class="k">)</span>.sh
</pre></div>
<h3 id="cpython-with-pyenv">cpython with pyenv<a class="anchor-link" href="#cpython-with-pyenv"> </a></h3><div class="highlight"><pre><span></span>pyenv install <span class="m">3</span>.8.12
</pre></div>
<p>And the use pip later.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="2.-Install-OpenHSI">2. Install OpenHSI<a class="anchor-link" href="#2.-Install-OpenHSI"> </a></h2><h3 id="via-conda">via conda<a class="anchor-link" href="#via-conda"> </a></h3><p>Create a new environment and install OpenHSI (including python dependancies and 6SV, except for cameras). You can change python version as required as well.</p>
<div class="highlight"><pre><span></span>pyenv activate miniforge3
conda create -n openhsi <span class="nv">python</span><span class="o">=</span><span class="m">3</span>.8 openhsi
conda activate openhsi
</pre></div>
<p>or using environment.yml in the main repo</p>
<div class="highlight"><pre><span></span>conda env create -f environment.yml
</pre></div>
<h3 id="via-pip">via pip<a class="anchor-link" href="#via-pip"> </a></h3><p>{% include tip.html content='If using raspi system python, some dependencies need to be installed using <code>sudo apt install python-opencv</code> etc.' %}
To create a new environment and install OpenHSI.</p>
<div class="highlight"><pre><span></span>pyenv virtualenv <span class="m">3</span>.8.12 openhsi
pyenv activate openhsi
pip install openhsi
</pre></div>
<h4 id="Install-6SV-(only-needed-for-pip-install)">Install 6SV (only needed for pip install)<a class="anchor-link" href="#Install-6SV-(only-needed-for-pip-install)"> </a></h4><div class="highlight"><pre><span></span>git clone https://github.com/robintw/6S.git
<span class="nb">cd</span> 6S
cmake -D <span class="nv">CMAKE_INSTALL_PREFIX</span><span class="o">=</span>/usr/local .
</pre></div>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="3.-Install-Camera-SDK">3. Install Camera SDK<a class="anchor-link" href="#3.-Install-Camera-SDK"> </a></h2><h3 id="Install-Lucid-Vision-Arena-SDK-(Sydney-Photonics/Robonation-OpenHSI)">Install Lucid Vision Arena SDK (Sydney Photonics/Robonation OpenHSI)<a class="anchor-link" href="#Install-Lucid-Vision-Arena-SDK-(Sydney-Photonics/Robonation-OpenHSI)"> </a></h3><p>The Robonation OpenHSI uses the detector from <a href="http://thinklucid.com">Lucid Vision Labs Inc</a>. Their full SDK is required to use the sensor with the OpenHSI libary. This can be acquired from <a href="https://thinklucid.com/downloads-hub/">https://thinklucid.com/downloads-hub/</a>.</p>
<p>To start the install, unzip the tar.gz package, i.e:</p>
<div class="highlight"><pre><span></span>tar -xf  ArenaSDK_&lt;version&gt;_Linux_&lt;platform&gt;.tar.gz
</pre></div>
<p>And run this configiuration script/installer:</p>
<div class="highlight"><pre><span></span><span class="nb">cd</span> ArenaSDK_Linux_&lt;platform&gt;
sudo sh Arena_SDK_&lt;platform&gt;.conf
</pre></div>
<p>{% include important.html content='You must keep the SDK files in the same location that you ran this command, or re-run the configiuration script. No files are copied or moved, just locations recorded for the arena python api to find.' %}
And then install the arena python library (this is the same on a conda based or pip based python env):</p>
<div class="highlight"><pre><span></span>pip install arena_api-&lt;version&gt;-py3-none-any.whl --no-dependencies
</pre></div>
<h4 id="Enable-Jumbo-Packets">Enable Jumbo Packets<a class="anchor-link" href="#Enable-Jumbo-Packets"> </a></h4><p>To ensure optimal performance you need to make sure your GigE link is setup for jumbo packets.</p>
<p>On Ubuntu system this can be done using (you may want to set this up to occur on startup):</p>
<div class="highlight"><pre><span></span>sudo ip link <span class="nb">set</span> eth0 mtu <span class="m">9000</span>
</pre></div>
<p>{% include note.html content='<code>eth0</code> should be the adapter name the camera is connected to, it may be different on your system.' %}</p>
<h4 id="Jumbo-Packets-on-a-Pi4">Jumbo Packets on a Pi4<a class="anchor-link" href="#Jumbo-Packets-on-a-Pi4"> </a></h4><p>Using Raspberry Pi OS, some additional effort is required.
<a href="https://support.thinklucid.com/knowledgebase/jumbo-frames-on-raspberry-pi/"> https://support.thinklucid.com/knowledgebase/jumbo-frames-on-raspberry-pi/</a></p>
<h3 id="Install-Spinnaker-SDK-(FLIR-based-OpenHSI)">Install Spinnaker SDK (FLIR based OpenHSI)<a class="anchor-link" href="#Install-Spinnaker-SDK-(FLIR-based-OpenHSI)"> </a></h3><p>Download and install the Spinnaker SDK and python wheel. - <a href="https://www.flir.com.au/products/spinnaker-sdk/">https://www.flir.com.au/products/spinnaker-sdk/</a>
{% include tip.html content='On an Intel/Amd, you want amd64/x86_64 version on raspi you want aarch64 or arm64.' %}
The 20.04 version has the follow dependancies:</p>
<div class="highlight"><pre><span></span>sudo apt install libusb-1.0-0 libavcodec58 libavformat58 libswscale5 libswresample3 libavutil56 qt5-default
</pre></div>
<p>and then installing the FLIR SDK.</p>
<div class="highlight"><pre><span></span>sudo sh install_spinnaker.sh
pip install --no-deps spinnaker_python-&lt;your needed version&gt;.whl
</pre></div>
<p>One of the prompts will ask you if you want to increase the USB buffer. Answer yes to this option.</p>
<p>More information on getting the FLIR SDK on a Raspberry Pi and Jetson is here
<a href="https://www.flir.com.au/support-center/iis/machine-vision/application-note/using-spinnaker-on-arm-and-embedded-systems/">https://www.flir.com.au/support-center/iis/machine-vision/application-note/using-spinnaker-on-arm-and-embedded-systems/</a></p>
<h4 id="On-Raspbian-64-bit">On Raspbian 64 bit<a class="anchor-link" href="#On-Raspbian-64-bit"> </a></h4><p>You will need to install Spinnaker however you'll find that <code>spinview-qt</code> will not install because it is missing a dependency which we actually don't require in <code>openhsi</code>. If you want to use a GUI called SpinView to view Camera output, then installing <code>spinview-qt</code> will let you use it but I haven't yet figured out how on Raspbian 64 bit. It's something to do with the QT5 package no longer being included in Debian 11+ package sources.</p>
<div class="highlight"><pre><span></span>sudo apt install qtbase5-dev qtchooser qt5-qmake qtbase5-dev-tools
</pre></div>
<p>To proceed without <code>spinview-qt</code>, follow the hacks found in <a href="https://askubuntu.com/questions/1335184/qt5-default-not-in-ubuntu-21-04">https://askubuntu.com/questions/1335184/qt5-default-not-in-ubuntu-21-04</a>. You extract the offending package, change a line stating the dependency, then repackaged the files.</p>
<p>More information on getting the FLIR SDK on a Raspberry Pi and Jetson is here <a href="https://www.flir.com.au/support-center/iis/machine-vision/application-note/using-spinnaker-on-arm-and-embedded-systems/">https://www.flir.com.au/support-center/iis/machine-vision/application-note/using-spinnaker-on-arm-and-embedded-systems/</a></p>
<h3 id="Install-Ximea-SDK-(Ximea-based-OpenHSI)">Install Ximea SDK (Ximea based OpenHSI)<a class="anchor-link" href="#Install-Ximea-SDK-(Ximea-based-OpenHSI)"> </a></h3><p>Navigate to <a href="https://www.ximea.com/support/wiki/apis/Python">https://www.ximea.com/support/wiki/apis/Python</a> and click on the Linux installation instructions. 
This will bring you to the page <a href="https://www.ximea.com/support/wiki/apis/XIMEA_Linux_Software_Package#Installation">https://www.ximea.com/support/wiki/apis/XIMEA_Linux_Software_Package#Installation</a> which lists everything you need to install the Ximea API.</p>
<p>A 64 bit OS is required to run the GUI called XIMEA CamTool</p>
<div class="highlight"><pre><span></span>wget https://www.ximea.com/downloads/recent/XIMEA_Linux_SP.tgz
tar xzf XIMEA_Linux_SP.tgz
<span class="nb">cd</span> package
./install
<span class="c1">#./install -pcie # -pcie flag needed for PCIE cameras</span>
</pre></div>
<p>If the build fails, try run the following first:</p>
<div class="highlight"><pre><span></span>sudo apt-get update <span class="o">&amp;&amp;</span> sudo apt-get install build-essential linux-headers-<span class="s2">&quot;</span><span class="k">$(</span>uname -r<span class="k">)</span><span class="s2">&quot;</span>
</pre></div>
<h4 id="Increase-USB-memory-limit">Increase USB memory limit<a class="anchor-link" href="#Increase-USB-memory-limit"> </a></h4><p>This is from the XIMEA page <a href="https://www.ximea.com/support/wiki/apis/Raspberry_Pi_4_Benchmarks#Increase-USB-memory-limit">https://www.ximea.com/support/wiki/apis/Raspberry_Pi_4_Benchmarks#Increase-USB-memory-limit</a></p>
<p>The default memory limit for buffers allocated for USB devices (usually 16MB) is too low for XIMEA USB cameras.This can be changed permanently following these steps:</p>
<ol>
<li>Open the file <code>/boot/firmware/cmdline.txt</code> in your preferred texteditor</li>
<li>Append the following (in the same line):
<code>usbcore.usbfs_memory_mb=0</code></li>
<li>Reboot the system</li>
<li>Check if the changes are applied. The following command should print <code>0</code>:<div class="highlight"><pre><span></span>cat /sys/module/usbcore/parameters/usbfs_memory_mb
</pre></div>
</li>
</ol>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="4.-Additional-Setup-for-sensor-package-on-Raspberry-Pi-(optional)">4. Additional Setup for sensor package on Raspberry Pi (optional)<a class="anchor-link" href="#4.-Additional-Setup-for-sensor-package-on-Raspberry-Pi-(optional)"> </a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="4.1---Enable-I2C-and-UART">4.1 - Enable I2C and UART<a class="anchor-link" href="#4.1---Enable-I2C-and-UART"> </a></h3><p>Open the Raspberry Pi config tool.</p>
<div class="highlight"><pre><span></span>sudo raspi-config
</pre></div>
<p>And enable I2C and UART. For more instructions see <a href="https://askubuntu.com/questions/1273700/enable-spi-and-i2c-on-ubuntu-20-04-raspberry-pi">https://askubuntu.com/questions/1273700/enable-spi-and-i2c-on-ubuntu-20-04-raspberry-pi</a>.
After enabling them, add the user pi to the group.</p>
<div class="highlight"><pre><span></span>sudo usermod -a -G dialout pi
sudo usermod -a -G i2c pi
</pre></div>
<p>Now, to use UART at high speed, we need to change a few more settings documented here
<a href="https://www.abelectronics.co.uk/kb/article/1035/serial-port-setup-in-raspberry-pi-os">https://www.abelectronics.co.uk/kb/article/1035/serial-port-setup-in-raspberry-pi-os</a></p>
<h3 id="4.2-Disable-serial-login-shell">4.2 Disable serial login shell<a class="anchor-link" href="#4.2-Disable-serial-login-shell"> </a></h3><p>remove <code>console=serial0,115200</code> from /boot/cmdline.txt
then reboot. This will allow us to run a higher baud rate.</p>
<h3 id="4.3---Use-PI0UART-instead-of-miniUART">4.3 - Use PI0UART instead of miniUART<a class="anchor-link" href="#4.3---Use-PI0UART-instead-of-miniUART"> </a></h3><p>Add to end of file /boot/config.txt we need to add a configuration to <code>/boot/config.txt</code>.</p>
<div class="highlight"><pre><span></span>sudo <span class="nb">echo</span> <span class="s1">&#39;dtoverlay=disable-bt&#39;</span> &gt;&gt; /boot/config.txt
</pre></div>
<p>Then in the terminal</p>
<div class="highlight"><pre><span></span>sudo systemctl disable hciuart
sudo reboot
</pre></div>
<p>{% include note.html content='The trade off with allowing higher baud rates is no bluetooth. ' %}</p>
<h3 id="4.4-Controlling-GPIO-pins">4.4 Controlling GPIO pins<a class="anchor-link" href="#4.4-Controlling-GPIO-pins"> </a></h3><p>If you are running this on a Raspberry Pi 4, you'll need to install the GPIO library.
<code>pip install RPi.GPIO</code></p>
<p>If you are running this on a Jetson, you'll need the corresponding Jetson version. 
<code>pip install Jetson.GPIO</code></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="4.5---Installing-the-Battery-Hat-software">4.5 - Installing the Battery Hat software<a class="anchor-link" href="#4.5---Installing-the-Battery-Hat-software"> </a></h3><p>To deploy the Raspberry Pi on a remote platform, it needs power. We use the X728 version 2.1 battery hat from Suptronics which lets us turn on and safe shutdown the Pi while indicating power left.</p>
<p>Since we are using Debian 11, we need to use systemd to enable /etc/rc-local which the battery hat scripts use. Follow the steps in 
<a href="https://www.linuxbabe.com/linux-server/how-to-enable-etcrc-local-with-systemd">https://www.linuxbabe.com/linux-server/how-to-enable-etcrc-local-with-systemd</a></p>
<p>The software for the battery hat can be found here:
<a href="https://wiki.geekworm.com/X728-Software">https://wiki.geekworm.com/X728-Software</a>
Be aware that you need to make some changes to get them to install
Change <code>python-smbus</code> to <code>python3-smbus</code>.</p>
<div class="highlight"><pre><span></span>sudo apt-get install python3-smbus
pip install smbus
</pre></div>
<p>Add PY_VERSION=3 on line 86 in x728-v2.1.sh to force the installer to use Python 3.
Python 2 is deprecated so convert x728pld.py to Python 3 syntax. All the print statements need <code>(</code> and <code>)</code>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="4.6---Mounting-SSD-without-sudo">4.6 - Mounting SSD without sudo<a class="anchor-link" href="#4.6---Mounting-SSD-without-sudo"> </a></h3><p>The reason why we want to mount the SSD without sudo is that we can then write to it without sudo.</p>
<p>First, identify your SSD using
<code>sudo fdisk -l</code>
I followed the steps in 
<a href="https://blog.onetwentyseven001.com/mounting-without-sudo/index.html">https://blog.onetwentyseven001.com/mounting-without-sudo/index.html</a></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Ready-to-go!">Ready to go!<a class="anchor-link" href="#Ready-to-go!"> </a></h2><p>Congratulations, you now have a system that can run your <code>openhsi</code>!</p>

</div>
</div>
</div>
</div>
 

