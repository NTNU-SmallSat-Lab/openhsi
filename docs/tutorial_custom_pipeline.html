---

title: Customising the OpenHSI Processing Pipeline


keywords: fastai
sidebar: home_sidebar

summary: "making the real-time, and post-processing pipeline work for you"
description: "making the real-time, and post-processing pipeline work for you"
nb_path: "nbs/14_tutorial_custom_pipeline.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/14_tutorial_custom_pipeline.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>{% include warning.html content='This tutorial is a work in progress.' %}
You can customise the level of processing you want in real-time. The API for doing this in post-processing is exactly the same and is based on <a href="/openhsi/data.html#CameraProperties.load_next_tfms"><code>CameraProperties.load_next_tfms</code></a> which every class dealing with datacubes will inherit. 
{% include tip.html content='If your processing pipeline works on raw datacubes in post-processing, you can directly use in real-time too. Keep in mind that, depending on the CPU load, the frame rate may decrease. ' %}
There are prebuilt recipies for setting the real-time processing pipeline (and for post-processing raw datacubes). 
You may want to customise this, for example, to implement direct georeferencing.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="The-Pipeline">The Pipeline<a class="anchor-link" href="#The-Pipeline"> </a></h2><p>Each callable within the pipeline is expected to ingest an array and output an array. The final array from the pipeline is then stored in a <a href="/openhsi/data.html#DataCube"><code>DataCube</code></a> buffer as the along-axis index is incremented.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">openhsi.capture</span> <span class="kn">import</span> <span class="n">ProcessDatacube</span>

<span class="n">dc2process</span> <span class="o">=</span> <span class="n">ProcessDatacube</span><span class="p">(</span><span class="n">fname</span> <span class="o">=</span> <span class="s2">&quot;path_to_datacube_file.nc&quot;</span><span class="p">,</span> <span class="n">processing_lvl</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                             <span class="n">json_path</span><span class="o">=</span><span class="n">json_path</span><span class="p">,</span> <span class="n">pkl_path</span><span class="o">=</span><span class="n">pkl_path</span><span class="p">)</span>
<span class="n">dc2process</span><span class="o">.</span><span class="n">load_next_tfms</span><span class="p">([</span><span class="n">proced_dc</span><span class="o">.</span><span class="n">dn2rad</span><span class="p">])</span>
<span class="n">dc2process</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
</pre></div>

</div>
</div>
</div>
</div>


